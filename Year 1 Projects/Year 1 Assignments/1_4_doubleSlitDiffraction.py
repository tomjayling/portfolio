# -*- coding: utf-8 -*-
# pylint: disable= E0012, fixme, invalid-name, no-member, W1401, W0632

''' Assignment 4 (Double slit diffraction; compulsory)

Assignment Tasks: 5

Restrictions:
    Do not change anything outside TODO blocks.
    Do not use import.
    Do not add pylint directives.

Guidance:
    All quantities are in SI units.
    Do not use for or loops when numpy functions or arrays can be used.

    The experimental data file does not provide any errors. This needs to be
    considered when working on this assignment.

    Task 2:
        The intensity in Fraunhofer diffraction of a double slit can be found
        in on the y1 Scientific computing page introducing this assignment,
        in the y1 Physics Laboratory Manual on the y1 Physics Laboratory
        Canvas course or in your UG Physics textbook.
        The 'double_slit(x, slit_width, slit_distance)' function uses the
        focal_length and wave_length defined outside of the function
        (on lines 70-71) rather than as parameters, so that the function
        can be passed to the curve_fit function without fitting the these
        parameters as well.

    Task 3:
        As we do not have errors for the measured quantities, the curve_fit
        function will not be called with the same named parameters as in the
        worked example on Canvas. Please consult the functions description to
        determine the required parameters. (You can use Ctrl-I to bring up the
        description.)

    Task 4:
        Create a two panel figure similar to worked example on Canvas.
        As experimental errors are not available, you should plot points rather
        than error bars in the main panel and the difference rather than the
        scaled difference in the second panel.
        Lengths should be displayed in micrometres. The Greek letter mu is
        generated by using the latex notation $\mu$, thus the full symbol for
        micrometre is generated by $\mu m$ or $\mu$m.
        The y-range of the lower plot should be symmetric around zero.
        The determined slit width and distance should be displayed including
        errors.

    Task 5:
        The experimental data is provided in a CSV file.
        (CSV stands for 'comma-separated values'.)

Author of template:
    Wolfgang Theis
    School of Physics and Astronomy
    University of Birmingham
'''

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec

# TODO: Assignment Task 1: Define FILENAME (path to file with data)
# path name of data file
FILENAME = r'C:\Users\princ\OneDrive\Documents\IPython\simulated_experimental_intensity.csv'
# End of Task 1; proceed to Task 2

# global variables to be used by the fitting function
focal_length = 5e-3     # 5 mm
wave_length = 600e-9    # 600 nm


def double_slit(x, slit_width, slit_distance, intensity_at_zero):
    """ calculate intensity distribution for a double slit

    Parameters
    ----------
    x: array of floats
        position on screen or CCD detector

    slit_width : float
        width of slit in metres

    slit_distance : float
        distance between centres of slits in metres

    intensity_at_zero: float
        intensity at x=0

    Returns
    -------
    intens : array of floats
        intensity on screen
    """
    # TODO: Assignment Task 2: write function body
    alpha = (np.pi*slit_width*x)/(wave_length*focal_length)
    beta = (np.pi*slit_distance*x)/(wave_length*focal_length)
    intens = intensity_at_zero*(np.sinc(alpha/np.pi)**2)*(np.cos(beta)**2)
    return intens
    # End of Task 2; proceed to Task 3


def fit_slit_parameters(x_pos, intensity, p0):
    """ determine best fit parameters for slit width and distance

    Parameters
    ----------
    x_pos: array of float
        position on screen

    intensity: array of float
        intensity at x_pos

    p0: array-like
        start values for fit parameters

    Returns
    -------
    popt, perr: arrays of floats
        popt are the best fit parameters and perr are the errors for these.
    """
    # TODO: Assignment Task 3: write function body
    #get the optimal parameters for the double slit equation with error
    popt, pcov = curve_fit(double_slit, x_pos, intensity, p0=p0)
    perr = np.sqrt(np.diag(pcov))
    return popt, perr
    # End of Task 3; proceed to Task 4


def create_figure(fig, data, popt, perr):
    """ create a figure with fully labelled graphs

    Parameters
    ----------
    fig: matplotlib figure object
        the figure object to add the the sub-plots to

    data: 2d array of floats
        data contains columns for x position and intensity

    Returns
    -------
    fig: matplotlib figure object
        the modified figure object
    """
    # TODO: Assignment Task 4: write function body
    # store optimal parameters by indexing the right values in popt and perr
    detailed_text = 'Optimal fit parameters are:\n'
    detailed_text += f'w = ({popt[0]:.3e} $\\pm$ {perr[0]:.3e}) m,\n'
    detailed_text += f'l = ({popt[1]:.3e} $\\pm$ {perr[1]:.3e}) m, \n'
    detailed_text += f'$I_0$ = ({popt[1]:.3e} $\\pm$ {perr[1]:.3e}) $Wm^-2$'
    # calculate intenisty using the double slit equation with optimal parameters
    fit = double_slit(data[:, 0], popt[0], popt[1], popt[2])
    gs = gridspec.GridSpec(2, 1, height_ratios=[4, 1])
    ax = fig.add_subplot(gs[0])
    # plot predicted intensity and intensity from the data, both against position
    ax.plot(data[:, 0], fit, 'r', label="fit")
    ax.plot(data[:, 0], data[:, 1], 'b.', label='"data"')
    #label first plot
    ax.set_xlabel("Position/$\mu m$")
    ax.set_ylabel("Intensity/$Wm^-2$")
    ax.set_title("Intensity Plot of Fraunhofer Diffraction")
    ax.legend()
    ax.text(0.98, 0.01, 'Thomas Ayling\n26.11.2020', transform=ax.transAxes,
            horizontalalignment='right', fontsize=12)
    ax.text(0.01, 0.85, detailed_text, transform=ax.transAxes,
            horizontalalignment='left', fontsize=8)
    # make second plot showing the difference between the fit and the data
    ax = fig.add_subplot(gs[1])
    ax.plot(data[:, 0], data[:, 1]-fit, 'r.')
    #label second plot
    ax.set_xlabel("Position/$\mu m$")
    ax.set_ylabel("difference")
    ax.set_title("Difference between data and fit")
    plt.savefig('activityfit.png')
    plt.show()
    return fig
    # End of Task 4; proceed to Task 5


def load_and_fit(file_name, p0):
    """ determine best fit parameters for slit width and distance

    Parameters
    ----------
    file_name: string
        name of the CSV file holding the measured intensities

    p0: array-like
        start values for fit parameters

    Returns
    -------
        popt, perr, data: arrays of floats
            popt are the best fit parameters and perr are the errors for these.
            data is the experimental data
    """
    # TODO: Assignment Task 5: write function body
    #load text into array using comma delimiter
    data = np.loadtxt(file_name, delimiter=',')
    #get optimal parameters with errors from fit_slit_parameters function
    popt, perr = fit_slit_parameters(data[:, 0], data[:, 1], p0)
    return popt, perr, data
    # End of Task 5; no further tasks


def main():
    """ determine best fit parameters for slit width and distance and plot """
    popt, perr, data = load_and_fit(FILENAME, [1e-5, 2e-5, 100])
    fig = plt.figure(figsize=(12, 10))
    fig = create_figure(fig, data, popt, perr)
    plt.show()



if __name__ == '__main__':
    # pylint: disable=E0012, C0112, C0111, C0304, C0325, C0413, C0411, C0301
    import unittest

    # Feel free to modify this flag to switch between plotting and unit tests
    plot_it = True

    if plot_it:
        # plot a test figure
        main()
    else:
        # do the unit tests

        class double_slitTests(unittest.TestCase):
            ''' tests for double_slit '''

            def test_intens0(self):
                self.assertAlmostEqual(double_slit(np.array(1e-9), 1e-6, 1e-6, 1), 1)

            def test_slitzero(self):
                x = np.arange(20)*focal_length*1e-3
                self.assertAlmostEqual(double_slit(x, 100*wave_length, 0, 1)[10], 0)

            def test_slitmax(self):
                x = np.arange(20)*focal_length*1e-3
                self.assertAlmostEqual(double_slit(x, 100*wave_length, 0, 1)[14], 0.046758098)

            def test_slitargmax(self):
                x = np.arange(20)*focal_length*1e-3
                self.assertAlmostEqual(np.argmax(double_slit(x, 100*wave_length, 0, 1)[10:]), 4)

            def test_distancezero(self):
                x = np.arange(20)*focal_length*1e-3
                self.assertAlmostEqual(double_slit(x, 1e-12, 100*wave_length, 1)[5], 0)

            def test_distanceone(self):
                x = np.arange(20)*focal_length*1e-3
                self.assertAlmostEqual(double_slit(x, 1e-12, 100*wave_length, 1)[10], 1)



        unittest.main(exit=False)
